addScript(name, tooltip, method) {
    if (tooltip == null) tooltip = name;
    menuItem = new JMenuItem(name);
    menuItem.addActionListener(this);
    menuItem.setToolTipText(tooltip);
    global.scriptMenu.add(menuItem);
    actionPerformed(ae) {
        this.invokeMethod(method, null);
    }
}

addScript("Randomize", "Randomize the selected wall polygons", "randomize");
addScript("Shadow", "Adds a shadow to the selected wall polygons", "shadow");
addScript("Round", "Rounds the corners of the selected wall polygons", "round");

import org.xpilot.jxpmap.*;


/************************ Misc Utils ******************************/


/**
 * Utility to check if a map objects is a regular wall polygon
 */
isWall(p) {
    return (p instanceof MapPolygon); 
}

/**
 * Finds a style with the matching id from the list
 */
findStyle(id, list) {
    for (style:list) 
        if (style.id.equals(id))
            return style;
    return null;
}

/**
 * Shows a message box.
 */
alert(msg) {
    JOptionPane.showMessageDialog(null, msg);
}

/**
 * Prompts the user for input.
 */
prompt(msg) {
    return JOptionPane.showInputDialog(null, msg);
}


/************************ Randomize script ******************************/


/**
 * Randomizes a wall polygon with the given amount of pixels.
 */
doRandomize(pixels, o) {
    if (isWall(o)) {    
        for (i = 0; i < o.getNumPoints(); i++) {
            p = o.getPoint(i);
            p.translate((int)((Math.random() - 0.5) * pixels * 64),
            (int)((Math.random() - 0.5) * pixels * 64));
            o.setPoint(i, p.x, p.y);
        }
    } else if (o instanceof Group) {
        for (i:o.members) doRandomize(pixels, i);
        o.invalidate();
    }
}

randomize() {
    if (editor.getSelectedObjects().isEmpty()) {
        alert("First select a polygon");
        return;
    }
    value = prompt("How many pixels to randomize");
    if (value == null) return;
    for (o:editor.selectedObjects)
        doRandomize(Integer.parseInt(value), o);
    editor.repaint();        
}


/************************ Shadow script ******************************/


/**
 * Adds a drop shadow to a wall polygon by creating
 * a dark gray decoration polygon below it.
 */
addShadow(polygon, style) {
    p = polygon.getPolygon();
    sp = new Polygon(p.xpoints, p.ypoints, p.npoints);
    for(i = 0; i < sp.npoints; i++) {
        sp.xpoints[i] += 240;
        sp.ypoints[i] -= 640;
    }
    sp.invalidate();
    decor = new Decoration();
    decor.addToFront(new MapPolygon(sp, style));
    editor.model.addToBack(decor);   
}

/**
 * Finds or creates the edge style and polygon style required
 * for a drop shadow.
 */
getShadowStyle() {
    model = editor.model;
    es = findStyle("hidden", model.edgeStyles);
    if (es == null) {
        es = new LineStyle("hidden", 1, Color.darkGray, LineStyle.STYLE_HIDDEN);
        model.edgeStyles.add(es);
    }
    ps = findStyle("shadow", model.polyStyles);
    if (ps == null) {
        ps = new PolygonStyle();
        ps.setColor(new Color(50,50,50));
        ps.setFillStyle(PolygonStyle.FILL_COLOR);
        ps.setId("shadow");
        ps.setVisibleInRadar(false);
        ps.setDefaultEdgeStyle(es);
        model.getPolyStyles().add(ps);
    }
    return ps;    
}

doShadow(o) {
    style = getShadowStyle();
    if (isWall(o)) addShadow(o, style);
    else if (o instanceof Group) {
        for (i:o.members) doShadow(i);
        o.invalidate();
    }
}

shadow() {
    if (editor.selectedObjects.isEmpty()) {
        alert("First select a polygon");
        return;
    }
    for (o:editor.selectedObjects) doShadow(o);
    editor.repaint();            
}


/************************ Round script ******************************/

/**
 * Moves a point to the specified direction the specified length.
 */
movePoint(p, dir, len) {
    a = len * Math.pow(p.distanceSq(dir), -0.5);
    p.translate((int)(a * (dir.x - p.x)), (int)(a * (dir.y - p.y)));
}    

/**
 * Rounds the corners of a wall polygon by adding one additional
 * vertex to each corner and moving the original vertex. The max parameter 
 * controls the maximum amount of pixels a vertex gets moved.
 */
doRound(mp, max) {
    if (!isWall(mp)) return;
    if (mp instanceof Group) {
        for (o:mp.members) 
            doRound(o, max);
        mp.invalidate();
    }
    if (mp.getNumPoints() < 3) return;
    minDist = 1 * 64;
    maxMove = max * 64;
    p2 = mp.getPoint(mp.getNumPoints() - 1);
    p3 = mp.getPoint(0);
    for (i = 1; i <= mp.getNumPoints(); i++) {
        p1 = p2;
        p2 = p3;
        p3 = mp.getPoint(i % mp.getNumPoints());
        d12 = p1.distance(p2);
        if (d12 <= minDist) continue;
        d23 = p2.distance(p3);
        if (d23 <= minDist) continue;
        pn = new Point(p2);
        movePoint(pn, p1, Math.min(maxMove, (int)(d12 / 2)));
        movePoint(p2, p3, Math.min(maxMove, (int)(d23 / 2)));
        mp.insertPoint(i - 1, pn);
        mp.setPoint(i, p2.x, p2.y);
        i++;
    }
}

round() {
    if (editor.selectedObjects.isEmpty()) {
        alert("First select a polygon");
        return;
    }
    value = prompt("How many pixels to round");
    if (value == null) return;
    max = Integer.parseInt(value);
    value = prompt("How many times to run");
    if (value == null) return;
    times = Integer.parseInt(value);   
    for (o:editor.selectedObjects)
        for (i = 0; i < times; i++)
            doRound(o, max);
    editor.repaint();
}

/************************ User scripts ******************************/


loadUserScripts() {
    String home = System.getProperty("user.home");
    f = new File(home + "/.jxpmaprc");
    if (!f.exists()) f = new File(home + "/jxpmaprc.bsh");
    if (f.exists()) source(f.getAbsolutePath());
}
loadUserScripts();
